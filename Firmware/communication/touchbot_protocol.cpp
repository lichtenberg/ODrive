/*
* The Touchbot protocol is a simpler, human readable alternative to the main native
* protocol.
* It is a modified version of the ASCII protocol that has one response line per request line
* Someday we can modify this to be a compact binary protocol.
*/

/* Includes ------------------------------------------------------------------*/

#include "odrive_main.h"
#include "../build/version.h" // autogenerated based on Git state
#include "communication.h"
#include "touchbot_protocol.hpp"
#include <utils.h>
#include <fibre/cpp_utils.hpp>

/* Private macros ------------------------------------------------------------*/
/* Private typedef -----------------------------------------------------------*/
/* Global constant data ------------------------------------------------------*/
/* Global variables ----------------------------------------------------------*/
/* Private constant data -----------------------------------------------------*/

#define MAX_LINE_LENGTH 256
#define TO_STR_INNER(s) #s
#define TO_STR(s) TO_STR_INNER(s)

/* Private variables ---------------------------------------------------------*/

#include "tcpacket.h"

#define RXSTATE_SYNC0   0
#define RXSTATE_SYNC1   1
#define RXSTATE_SYNC2   2
#define RXSTATE_SYNC3   3
#define RXSTATE_HEADER  4
#define RXSTATE_PAYLOAD 5

static tcpacket_t rxpacket;             // no packet pool yet, this is our RX buffer
static tcpacket_t txpacket;             // ditto, this is our TX buffer

static uint8_t *rxPtr;                  // state to track our packet receive.
static int rxRemlen = 0;
static int rxState = RXSTATE_SYNC0;



/* Private function prototypes -----------------------------------------------*/
/* Function implementations --------------------------------------------------*/

// @brief Sends a line on the specified output.

static void tprespond(StreamSink& output, tcpacket_t *pkt)
{
    size_t len = tcpkt_size(pkt);
    output.process_bytes((uint8_t*)pkt, len, nullptr); // TODO: use process_all instead
}


static void touchbot_protocol_process_packet(tcpacket_t *rxpkt, StreamSink& response_channel) 
{
    tcpacket_t *txpkt = &txpacket;
    static_assert(sizeof(char) == sizeof(uint8_t));
    unsigned int a;
    float f0,f1;
    int32_t i0;
    Axis *axis;
    char *pname;
    Endpoint *endpoint;

    // Prep the response packet.  Copy over the sequence # and command from the RX packet.
    tcpkt_init(txpkt);
    txpkt->packet.tc_sts = TCSTS_OK;
    txpkt->packet.tc_cmd = rxpkt->packet.tc_cmd | TCCMD_RESPBIT;
    txpkt->packet.tc_seq = rxpkt->packet.tc_seq;

    // Handle each command type.
    // We don't do much about badly formed packets... yet.
    switch (rxpkt->packet.tc_cmd) {
        case TCCMD_PING:
            break;

        case TCCMD_POSITION:
            a = (unsigned int) tcpkt_getint(rxpkt,0);       // selected axis

            if (a < AXIS_COUNT) {
                f0 = tcpkt_getfloat(rxpkt,0);      // target position
                axis = axes[a];
                axis->controller_.set_pos_setpoint(f0, 0.0, 0.0);
                axis->watchdog_feed();
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            break;
            
        case TCCMD_POSLIMITS:
            a = (unsigned int) tcpkt_getint(rxpkt,0);       // selected axis

            if (a < AXIS_COUNT) {
                f0 = tcpkt_getfloat(rxpkt,0);      // target position
                f1 = tcpkt_getfloat(rxpkt,1);      // max velocity
                axis = axes[a];
                axis->controller_.set_pos_setpoint(f0, 0.0, 0.0);
                axis->controller_.config_.vel_limit = f1;
                axis->watchdog_feed();
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            break;

        case TCCMD_TRAPTRAJ:
            a = (unsigned int) tcpkt_getint(rxpkt,0);       // selected axis

            if (a < AXIS_COUNT) {
                f0 = tcpkt_getfloat(rxpkt,0);      // goal position
                axis = axes[a];
                axis->controller_.move_to_pos(f0);
                axis->watchdog_feed();
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            break;
            
        case TCCMD_ZEROENCODER:
            a = (unsigned int) tcpkt_getint(rxpkt,0);       // selected axis

            if (a < AXIS_COUNT) {
                axis = axes[a];
                // Only works if axis state is 'idle'
                if (axis->current_state_ == Axis::AXIS_STATE_IDLE) {
                    axis->encoder_.set_linear_count(0);
                } else {
                    txpkt->packet.tc_sts = TCSTS_ERR_STATE;
                }
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }

            break;

        case TCCMD_STATUS:
            tcpkt_addfloat(txpkt,axes[0]->encoder_.pos_estimate_);
            tcpkt_addfloat(txpkt,axes[0]->encoder_.vel_estimate_);
            tcpkt_addfloat(txpkt,axes[1]->encoder_.pos_estimate_);
            tcpkt_addfloat(txpkt,axes[1]->encoder_.vel_estimate_);
            tcpkt_addint(txpkt,system_stats_.uptime);
            tcpkt_addint(txpkt,axes[0]->current_state_);
            tcpkt_addint(txpkt,axes[1]->current_state_);
            break;

        case TCCMD_GETIPROP:
            pname = tcpkt_getstring(rxpkt);
            endpoint = application_endpoints_->get_by_name(pname, strlen(pname)+1);
            i0 = 0;
            if (endpoint) {
                char response[10];

                if (endpoint->get_string(response,sizeof(response))) {
                    i0 = atoi(response);
                } else {
                    txpkt->packet.tc_sts = TCSTS_ERR_VALUE;
                }
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            tcpkt_addint(txpkt,i0);
            break;

        case TCCMD_GETFPROP:
            pname = tcpkt_getstring(rxpkt);
            endpoint = application_endpoints_->get_by_name(pname, strlen(pname)+1);
            f0 = 0.0;
            if (endpoint) {
                char response[10];

                if (endpoint->get_string(response,sizeof(response))) {
                    f0 = strtof(response,NULL);
                } else {
                    txpkt->packet.tc_sts = TCSTS_ERR_VALUE;
                }
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            tcpkt_addfloat(txpkt,f0);
            break;

        case TCCMD_SETIPROP:
            pname = tcpkt_getstring(rxpkt);
            i0 = tcpkt_getint(rxpkt,0);

            // Can we set integer properties by float? less ugly.
            endpoint = application_endpoints_->get_by_name(pname, strlen(pname)+1);
            if (endpoint) {
                char value[MAX_LINE_LENGTH];
                snprintf(value,sizeof(value),"%d",(int)i0);
                endpoint->set_string(value,sizeof(value));
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }

            break;

        case TCCMD_SETFPROP:
            pname = tcpkt_getstring(rxpkt);
            f0 = tcpkt_getfloat(rxpkt,0);

            endpoint = application_endpoints_->get_by_name(pname, strlen(pname)+1);
            if (endpoint) {
                endpoint->set_from_float(f0);
            } else {
                txpkt->packet.tc_sts = TCSTS_ERR_PARAM;
            }
            break;

        case TCCMD_FEEDWATCHDOG:
            axes[0]->watchdog_feed();
            axes[1]->watchdog_feed();
            break;

        default:
            txpkt->packet.tc_sts = TCSTS_ERR_CMD;
            break;
    }


    // Generate the CRC
    txpkt->packet.tc_crc = crc16((char *) txpkt, (unsigned short) tcpkt_size(txpkt));

    // Send back the response.
    tprespond(response_channel,txpkt);

}


static bool touchbot_protocol_process_byte(uint8_t b)
{
    bool done = false;

    // First 4 states get us through checking the sync bytes.
    switch (rxState) {
        default:
        case RXSTATE_SYNC0:
            rxPtr = (uint8_t *) &rxpacket;
            rxRemlen = 0;
            if (b == TC_SEAL0) {
                *rxPtr++ = b;
                rxState = RXSTATE_SYNC1;
            }
            break;

        case RXSTATE_SYNC1:
            if (b == TC_SEAL1) {
                *rxPtr++ = b;
                rxState = RXSTATE_SYNC2;
            } else {
                rxState = RXSTATE_SYNC0;
            }
            break;

        case RXSTATE_SYNC2:
            if (b == TC_SEAL2) {
                *rxPtr++ = b;
                rxState = RXSTATE_SYNC3;
            } else {
                rxState = RXSTATE_SYNC0;
            }
            break;

        case RXSTATE_SYNC3:
            if (b == TC_SEAL3) {
                *rxPtr++ = b;
                // the rest of the bytes of the header are the fixed part.
                // so it's just the struct minus our seal.
                rxRemlen = TC_HDRSIZE - sizeof(uint32_t);
                rxState = RXSTATE_HEADER;
            } else {
                rxState = RXSTATE_SYNC0;
            }
            break;

        case RXSTATE_HEADER:
            *rxPtr++ = b;
            rxRemlen--;

            if (rxRemlen == 0) {
                // compute the length of the payload.
                rxRemlen = tcpkt_size(&rxpacket) - TC_HDRSIZE;

                // If the remaining length is still zero, kick the packet out.
                if (rxRemlen == 0) {
                    done = true;                            // tell receive loop to process packet
                    rxState = RXSTATE_SYNC0;                // back to sync state.
                } else {
                    rxState = RXSTATE_PAYLOAD;
                }
            }
            break;

        case RXSTATE_PAYLOAD:
            *rxPtr++ = b;
            rxRemlen--;

            if (rxRemlen == 0) {
                done = true;                            // tell receive loop to process packet
                rxState = RXSTATE_SYNC0;                // back to syncs state.
            }
    }

    return done;
}

void touchbot_protocol_parse_stream(const uint8_t* buffer, size_t len, StreamSink& response_channel) 
{
    while (len--) {
        if (touchbot_protocol_process_byte(*buffer++)) {
            unsigned short crc;
            // process the packet.   The state has already been reset
            // to start handling the next one.

            // check CRC
            crc = rxpacket.packet.tc_crc;
            rxpacket.packet.tc_crc = 0;         // zero it before computing.
            if (crc16((char *) &rxpacket, (unsigned short) tcpkt_size(&rxpacket)) != crc) {
                // XXX handle bad CRC here.
            }

            // otherwise pass it up.
            touchbot_protocol_process_packet(&rxpacket,response_channel);
        }
    }
}
